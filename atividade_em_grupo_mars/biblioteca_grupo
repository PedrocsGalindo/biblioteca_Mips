# Pedro Cesar, Vinicius lima, Felipe paz e Paulo Daniel
# atividade 1VA, Arquitetura de hardware, 2024.2

.data

# NOMES DOS ARQUIVOS --------------------------------------------------------------------------------------- 
usersFile:	.asciiz "users.txt"
booksFile:	.asciiz "books.txt"
loanFile:	.asciiz "emprestimos.txt"
local_temp: .asciiz "C:/Users/luism/Desktop/projeto_Assembly/temp.txt"
local_livros: .asciiz "C:/Users/luism/Desktop/projeto_Assembly/lista_livros.txt"	

# MENSAGENS PADROES ----------------------------------------------------------------------------------------
banner : .asciiz "TurmaDoCodigo-shell>>"
msgAcervo: .asciiz "ACERVO: \n"
msgLivroApagado: .asciiz "\nRegistro do livro apagado!"
msgApagarArquivos: .asciiz "Arquivos limpos com sucesso!\n"
msgFim: .asciiz  "\n---------------------------------------------"

#Formato de entrada "comando arg1 arg2 arg3 ..."

msgEndRun: .asciiz "endRun"
msgCreatUser: .asciiz "cru"
msgCreatBook: .asciiz "crb"
msgCreatBookLoan: .asciiz "crbl"
msgCheckBookAvailability: .asciiz "ckba" 

msg:    .asciiz "Hora atual: "
sep:    .asciiz ":"
newl:   .asciiz "\n"  # Nova linha para formatar a saída da hora
prompt: .asciiz "Digite a data (dia/mes/ano): "
input:  .space 11  # Espaço para armazenar a data (10 caracteres + 1 para o terminador nulo)

msgTeste: .asciiz "12345"

# BUFFERS --------------------------------------------------------------------------------------------------
			  # Nao pode ter espao nos espaços do bloco (talvez depois melhorar a logica para suportar isso)
bufferInput:  .space 100  # Comando do usuario 
bufferUser:  .space 68    # 30 - primeiro bloco, 1 - virgula,  5 - segundo bloco, 1 - virgula,  30 - segundo bloco, 1 - quebra de linha
bufferLinha: .space 68    # 30 - primeiro bloco, 1 - virgula,  5 - segundo bloco, 1 - virgula,  30 - segundo bloco, 1 - quebra de linha
bufferByte: .space 1
bufferWord: .space 4
bufferLivro: .align 0 
             .space 70 
byte: .align 0
      .space 1
bufferISBN: .align 0
            .space 14
                       
backspace:  .byte 0x08    
space:      .byte 0x20     # espaco em branco 

.text
.globl main

# REGISTRADORES FIXOS ----------------------------------------------------------------------------------------
# Sempre que for usar os registradores fixos  necessario varificar se vai alterar algum outro valor, ou caso va usar alguma função que tenha esses registradores (necessario manter uma copia temporaria)
# Caso necessario antes do input tem que salvar o valor de $a0 

# $s0 : indice do bufferUser, indice do bufferUser(inputUser), 
# $s1 : indice do bufferLinha
# $a0 : buffer(clearBuffer), buffer(commaInBuffer), arquivo(saveData), mensagem(showMsg), contador(cleardDisplay), caracterEscrito(inputUser)
# $a1 : indice(clearBuffer), indice(commaInBuffer), buffer(saveData) 
# $a2 : tamanhoString(saveData)
main:

	li $s0, 0   		# numero de elementos do bufferUser (para adicinar elemento o numero ta certo, mas para carregar é preciso diminuir 1)
	li $s1, 0		# sera usado para salvar referencia do descritor de arquivo (para poder iterar)
	
	la $a0, banner
	jal showMsg
	jal inputUser
	
	la $a0, bufferInput
	la $a1, msgEndRun
	jal checkUserFunc
	beqz $a1, endRun
	
	la $a0, bufferInput
	la $a1, msgCreatUser
	jal checkUserFunc
	beqz $a1 creatUser
	
	la $a0, bufferInput
	la $a1, msgCreatBook
	jal checkUserFunc
	beqz $a1, creatBook
	
	la $a0, bufferInput
	la $a1, msgCreatBookLoan
	jal checkUserFunc
	#beqz $a1, creatBookLoan
	
	la $a0, bufferInput
	la $a1, msgCheckBookAvailability
	jal checkUserFunc
	beqz $a1, checkBookAvailability
	
	#jal solicitarhora #para pegar a hora atual
	
	j endRun
	
#---------------------------------------FUNCOES FELIPE------------------------------------------------- 	
	
listarLivros:  # fun��o para listar os livros do ACERVO
		la $a0, msgAcervo
		li $v0, 4
		syscall # imprima a mensgem ACERVO
		la $a0, local_livros
		jal abrirArquivoLeitura
		
		loopListarLivros: # loop que ir� printar printar pegar uma linha, printar e depois limpar o buffer at� n�o existirem mais registros no arquivo
			jal lerArquivoLinhaLivro 
			jal printarLinhaLivro
			jal limparBufferLinhaLivro
			beqz $s1,finalizarloopListarLivros
			j loopListarLivros
		finalizarloopListarLivros: # fun��o para finalizar
			la $a0, msgFim 
			li $v0, 4
			syscall
			li $v0, 16 #fecha o arquivo
			syscall
			j main # volta para a MAIN
		
	
#abre o arquivo passado em $a0 no modo leitura		
abrirArquivoLeitura:
	#$a0 deve conter o caminho do arquivo
	li $v0, 13
	li $a1, 0
	syscall
	move $s0, $v0
	jr $ra
	
#abre o arquivo passado em $a0 no modo escrita		
abrirArquivoEscrita:
	
	li $v0,13
	li $a1, 1
	syscall 
	move $s5, $v0
	jr $ra

#fecha o arquivo cujo descritor estiver salvo em $a0	
fecharArquivo:
	li $v0, 16
	syscall
	jr $ra
	
		 
lerArquivoLinhaLivro:
	# O Descritor do arquivo deve estar em $s0
	move $a0, $s0 # passa o descritor para $a0
	li $t2, 0x0A # character que representa a quebra de linha
	li $t3, 0 #vari�vel para iterar sobre o bufferLinha
		
	loopLeitura: #ir� ler byte a byte do arquivo e incrimentar no bufferLinha at� encontrar uma quebra de linha
		la $a1, byte 
		li $a2,1
		li $v0, 14
		syscall # l� um byte do arquivo
		lb $t1, byte #load byte para o registrador $t1
		beqz $v0, finalizarLerArquivoLinha #se o arquivo j� foi totalmente lido
		sb $t1, bufferLivro($t3) #incrementa o byte no buffer
		addi $t3, $t3, 1 # incrementa 1 a vari�vel de itera��o
		beq $t1, $t2, finalizarLerArquivoLinha # -> Se $t1 for igual a $t2, significa que ele encontrou a quebra de linha e desvia para "finalizar"
		j loopLeitura
	finalizarLerArquivoLinha:
		move $s1, $v0
		jr $ra
			 
printarLinhaLivro: 
	li $v0, 4
	la $a0, bufferLivro
	syscall
	jr $ra
			
		
#limpa o que estiver contido em buffer linha			
limparBufferLinhaLivro:
	li $t0, 0 #variavelde irera��o
	li $t1, 70 # numero de characteres a serem limpos
	li $t2,0x00 # representa o null
	loopLimparBufferLinhaLivro: 
		beq $t0,$t1,finalizarLoopLimparBufferLinhaLivro # se j� tiverem sido apagados todos os registros ele finaliza
		sb $t2,bufferLivro($t0) # aapga o character
		addi $t0, $t0, 1 #incrementa 1 a vari�vel de itera��o
		j loopLimparBufferLinhaLivro 
	finalizarLoopLimparBufferLinhaLivro :
		jr $ra
		
#fun��o para truncar todos os registros			
LimpaArquivo:
    la $a0, local_livros      # Carrega o caminho do arquivo
    li $v0, 13                # Syscall para abrir arquivo
    li $a1, 1              # Flags: 1 (O_WRONLY) | 512 (O_TRUNC)               # N�o usa permiss�o extra
    syscall                   # Realiza a syscall para abrir o arquivo


    # Fechar o arquivo
    li $v0, 16                # Syscall para fechar arquivo
    move $a0, $s0             # Passa o descritor do arquivo
    syscall                   # Realiza a syscall para fechar o arquivo

    # Exibir mensagem de sucesso
    li $v0, 4
    la $a0, msgApagarArquivos
    syscall

    # Finalizar o programa
    li $v0, 10
    syscall
    
    
removerRegistroLivro: 
	#abrindo o arquivo de livros
	la, $a0, local_livros
	jal abrirArquivoLeitura
	#s0 cont�m o descitor de local_livros
	la, $a0, local_temp
	jal abrirArquivoEscrita
	#s5 cont�m o descritor de local_temp
	#imprimindo mensagem do ISBN
	li $v0, 4
	la $a0, msgISBN
	syscall 
	#pegando o ISBN do usuario
	li $v0,8
	la $a0, bufferISBN
	li $a1,14
	syscall
	#fechando os arquivos
	
	
	#Esse loop transfere linha por linha do arquivo de Acervo, e transfere para o arquivo temporario, exceto a linha que eu quero apagar
	loopTransferirRegistroLivroTemp:
		jal procurarLivro # procura o livro 
		li $t2, -1
		li $t1, 1
		beq $v0, $t2, finalizarloopTransferirRegistroLivro # se $t2 for -1 significa que todo o arquivo j� foi lido
		beq $v0, $t1,loopTransferirRegistroLivroTemp # se ele encontrou o registro a ser apagado ele continua no loop
		beq $v0, $zero, escreverLivroArquivoTemp # se ele n�o encontrou o registro que deve ser apagado ele escreve no arquivo tempor�rio

	finalizarloopTransferirRegistroLivro:
	# Fecha os arquivos
		move $a0,$s0
		jal fecharArquivo
		move $a0, $s5
		jal fecharArquivo
		
	# abre os arquivos para passar do temporario para o original
		la $a0, local_livros
		jal abrirArquivoEscrita 
		la $a0, local_temp
		jal abrirArquivoLeitura
		
		j loopTransferirRegistroLivro
		
	#escreve o que estiver contido em bufferLivro no arquivo tempor�rio	
	escreverLivroArquivoTemp:
		jal contarCharacteresLinhaLivro #conta o tamanho de characteres passados para BufferLivro
		move $t0,$v0 # move a quantidade passada para $t0
		addi $t0,$t0, 1
		li $v0, 15
		move $a0, $s5 # $s5 deve conter o descritor do arquivo temporario no modo escrita
		la $a1, bufferLivro #escreve o que estiver contido em bufferLivro
		move $a2, $t0 
		syscall
		jal limparBufferLinhaLivro
		j loopTransferirRegistroLivroTemp
		
		
	#loop para repassar os registros do arquivo tempor�rio para o original
	loopTransferirRegistroLivro:
		jal lerArquivoLinhaLivro
		beqz $s1, finalizarloopTransferirRegistroTemp
		jal escreverLivroArquivoLivro
	#escreve no arquivo original
	escreverLivroArquivoLivro:
		jal contarCharacteresLinhaLivro	
		move $t0, $v0
		addi $t0,$t0, 1
		li $v0, 15
		move $a0, $s5
		la $a1, bufferLivro
		move $a2, $t0
		syscall
		jal limparBufferLinhaLivro
		j loopTransferirRegistroLivro
	#finaliza o loop	
	finalizarloopTransferirRegistroTemp:
		# Fecha os arquivos
		move $a0,$s0
		jal fecharArquivo
		move $a0, $s5
		jal fecharArquivo
		#mensagem de arquivo apagado
		la $a0, msgLivroApagado
		li $v0, 4
		syscall
		
		li $v0, 10
		syscall
		
		
# conta a quantidade de characteres do bufferLinha e retorna at� o indice antes da quebra de linha	
contarCharacteresLinhaLivro: 
	li $t0, 0 # registrador de itera��o
	li $t1, 0x0A # character que representa a quebra de linha
	loopContarCharacteresLinhaLivro:
		lb $t2, bufferLivro($t0) #passa o character para $t2
		beq $t2,$t1,finalizarloopContarCharacteresLinhaLivro # se encontrar a quebra de linha ele finaliza a contagem
		addi $t0,$t0,1 #incrementa 1 a vari�vel de itera��o
		j loopContarCharacteresLinhaLivro
	finalizarloopContarCharacteresLinhaLivro:
		move $v0,$t0 
		jr $ra
		
# essa fun��o ela pega uma registro de livro, compara se esse registro cont�m o ISBN que foi inserido pelo usu�rio, se cont�m ele retorna 1, se n�o cont�m ele retorna 0.
# E se o arquivo j� foi totalmente lido ele retorna -1
procurarLivro:
	#O ISBN deve estar em bufferISBN
	move $t8, $ra #  armazena o retorno em $t8
	jal lerArquivoLinhaLivro # l� a proxima linha do arquivo
	beqz $s1, finalArquivo #se o arquivo j� foi totalmente lido ele finaliza o procurar livro
	li $a0,2 # campo conde est� o ISBN
	jal pegarISBNLivro # retorna o ISBN daquele registro
	move $a0, $v0 # indice do inicio do ISBN
	move $a1, $v1 # indice do final do ISBN
	jal compararISBN #compara os ISBNs
	move $ra, $t8
	jr $ra
	finalArquivo:
		li $v0, -1
		move $ra, $t8
		jr $ra
		
# Essa fun��o pega o ISBN do registro do livro passado em BufferLivro	
pegarISBNLivro: 
	move $t0,$a0 # a0 deve conter o bloco do atributo na linha
	move $t9, $ra # deixa armazenado a funcao que chamou
	li $t1, 0 # variavel para iterar sobre a linha
	li $t2, 0 # variavel para contar o numero de linhas lidas
	li $t3, 0x2C #character que representa uma virgula
	j loopAtributoLivro
	
	somarLinha:
		addi $t2,$t2,1	#soma 1 ao registrador $t2 que cont�m a quantidade de linhas
		addi $t1, $t1, 1 # pula para o pr�ximo character de bufferLivro
		j loopAtributoLivro
		
	loopAtributoLivro:
		beq $t2,$t0,finalizarLoopAtributoLivro # se $t2 e $t0 forem iguais significa que j� temos o endere�o do primeiro digito do ISBN
		lb $t5, bufferLivro($t1) # atribui o character para %t5
		beq $t3,$t5,somarLinha # se encontrar uma vigula soma 1 ao registrador $t3
		addi $t1,$t1,1 #incrementa 1 ao registrador de itera��o
		j loopAtributoLivro
		
	finalizarLoopAtributoLivro:
		addi $t4,$t1,12#atribui o indice do ultimo indice antes da proxima virgula (tendo em vista que o ISBN tem 13 digitos)
		move $v0,$t1 # passando as vari�veis de retorno
		move $v1,$t4
		move $ra $t9 #pegando a funcao que chamou inicialmente 
		jr $ra # voltando para procurarLivro
		
		
#Compara o ISBN inserido pelo usu�rio com o ISBN contido em bufferLivro
compararISBN:
	move $t9,$ra # armazena a vari�vel de retorno
	li $t0,0x2C # representa a virgula
	move $t1, $a0 # passando os par�metros de entrada para os registradores do tipo t ($t1 � o endere�o do primeiro digito do ISBN e %t2 � o ultimo digito do isbn)
	move $t2, $a1
	li $t3, 0 #variavel para iterar sobre o bufferISBN
		
	loopContarCharacteresAtributo:
		lb $t5, bufferISBN($t3) #atribui o character do Buffer ISBN para %t5
		lb $t6, bufferLivro($t1) # atribui o character do bufferLivro para $t6
		bgt $t1,$t2,finalizarLivroIgual # se $t1 foi maior que $t2 significa que todo o bufferLivro j� foi analisado (ent�o os livros s�o iguais)
		bne $t5,$t6,finalizarLivroDiferente # se $t5 e $t6 forem diferentes significa que os ISBNS s�o diferentes
		addi $t1,$t1,1 # adiciona +1 mais para a pr�xima itera��o
		addi $t3,$t3,1
		j loopContarCharacteresAtributo
	finalizarLivroDiferente:
		li $v0,0 # se for diferente ele retorna 0
		move $ra, $t9
		jr $ra
	finalizarLivroIgual:
		li $v0,1 # se for igual ele retorna 1
		move $ra,$t9
		jr $ra

	
		
			
#---------------------------------FUNCOES FELIPE---------------------------------------------------			
					
						
	
checkUserFunc:
# parametros
# $a0 -> endereco do buffer
# $a1 -> string comparar com primeira palavra do buffer
# retorna
# $a1 -> 0 = iguais

	lb $t0, 0($a0)
	lb $t1, 0($a1)
	beq $t1, $zero, termino		# verifica se a palavra procurada chegou ao fim
	bne $t0, $t1, diferente
	addi $a0, $a0, 1
	addi $a1, $a1, 1
	j checkUserFunc
	
termino:
	li $t2, 0x20	     	  # virgula
	beq $t0, $t2, equals      # verifica se a palavra procurada no bufferLinha chegou ao fim
	beqz $t0, equals     	  # secundo bloco temrina em virgula, nao tem espaco vazio
	j diferente
	
equals:
	li $a1, 0
	j return
	
diferente:
	li $a1, 1
	j return

checkBookAvailability:
# A string procurada sera o primeiro argumento do bufferInput

	addi $sp, $sp, -4   
	sw $ra, 0($sp)     	     # salvar referencia
	
	la $a2, bufferInput
	addi $a2, $a2, 5
	jal seachBookByISBM	     # o "objeto", caso exista, estara por enteiro no buffer linha

	la $a1, bufferLinha
	add $a0, $a1, 36		# endereco do 3 bloco do bufferLinha
	la $a2, bufferInput
	addi $a2, $a2, 5
	jal loopCheckBookAvailability
	
	addi $sp, $sp, 4
	lw $ra, 0($sp)     	   
	
	j return

loopCheckBookAvailability:
#Parametro
#$a2 -> string procurada
#$a0 -> endereco do 3 bloco do bufferLinha	
	lb $t0, 0($a0)
	li $t1, '-'
	beq $t0, $t1, showMsg
	addi $a0, $a0, 1
	j loopCheckBookAvailability
	
seachBookByISBM:
#Parametro
#$a2 -> string procurada
	addi $sp, $sp, -4   
	sw $ra, 0($sp)     	     # salvar referencia
	
	move $t0, $a2		     # salvar referencia 
	
	la $a0, booksFile
	jal openFile		     # Abre o arquivo, deixando disponivel para leitura, salvando o descritor em $s1
		
	move $a2, $t0		     # recupera a referencia
	
	lw $ra, 0($sp)     	     # recupera referencia
	addi $sp, $sp, 4   
	
	addi $sp, $sp, -4   
	sw $ra, 0($sp)     	     # salvar referencia
		
	li $a1, 2 		     # segundo bloco
	move $a2, $a2
	jal searchStringOnFile
	
	lw $ra, 0($sp)     	     # recupera referencia
	addi $sp, $sp, 4   
	
	lw $ra, 0($sp)     	     # recupera referencia
	addi $sp, $sp, 4   
	
	j return

seachUserByRegister:
#Parametro
#$a2 -> string procurada
	addi $sp, $sp, -4   
	sw $ra, 0($sp)     	     # salvar referencia
	
	move $t0, $a2		     # salvar referencia 
	
	la $a0, usersFile
	jal openFile		     # Abre o arquivo, deixando disponivel para leitura, salvando o descritor em $s1
		
	move $a2, $t0		     # recupera a referencia
	
	lw $ra, 0($sp)     	     # recupera referencia
	addi $sp, $sp, 4   
	
	addi $sp, $sp, -4   
	sw $ra, 0($sp)     	     # salvar referencia
		
	li $a1, 2 		     # segundo bloco
	move $a2, $a2
	jal searchStringOnFile
	
	lw $ra, 0($sp)     	     # recupera referencia
	addi $sp, $sp, 4   
	
	lw $ra, 0($sp)     	     # recupera referencia
	addi $sp, $sp, 4   
	
	j return

	
searchStringOnFile:
#Retorna $a1 -> 0 = encontrou , -1 = nao encontrou
#Parametros
#$a1 -> bloco (1, 2 ou 3)
#$a2 -> string procurada

	addi $sp, $sp, -4   
	sw $ra, 0($sp)     	     # salvar referencia
	
	move $t0, $a1
	move $t1, $a2
	
	jal readFile		     # No bufferLinha tem uma linha do arquivo (no looping vai da primeira a ultima)
	
	lw $ra, 0($sp)     	     # recupera referencia
	addi $sp, $sp, 4   
	
	li $t2, -1
	beq $a1, $t2, endSearchEndFile	     # checa se chegou no final do arquivo
	
	move $a1, $t0	  	     # recuperando as referencias alteradas em readFile
	move $a2, $t1 
		
	move $a2, $a2 
	li $t0, 1	  	     
	li $t4, 2    
	li $t2, 3
	li $a0, 0				# Indice dos buffers (para comparar os caracteres em posições corretas)
	la $a3, bufferLinha			# endereco do primiero elemento do bloco 1
	beq $a1, $t0, searchBlock
	addi $a3, $a3, 31			# endereco do primiero elemento do bloco 2
	beq $a1, $t4, searchBlock
	addi $a3, $a3, 5			# endereco do primiero elemento do bloco 3
	beq $a1, $t2, searchBlock
	bgt $a1, $t2, return			# Caso, termine a busca achando

endSearchEndFile:
	lw $ra, 0($sp)     	     # recupera referencia
	addi $sp, $sp, 4   
	j return
	
searchBlock:
#Parametros
# $a0 -> indice dos buffers
# $a3 -> endereco do bloco no bufferLinha
# $a2 -> string procurada

	add $t0, $a2, $a0	# posicoes dos caracteres (string procurada)
	add $t1, $a3, $a0	# posicoes dos caracteres (string do buffer)

	lb $t0, 0($t0)		# caracteres
	lb $t1, 0($t1)
	
	move $t2, $a3 		# salva referencia
	
	move $a3, $t1		# carrega o caracter, que pode ser passado para funcao endSearch
	
	beq $t0, $zero, endSearch
	bne $t0, $a3, diferents
	
	move $a3, $t2 		# recupera referencia
	
	addi $a0, $a0, 1	# incrementa o indice
	
	j searchBlock

endSearch:
	li $t4, 0x2C		     # virgula
	beq $a3, $t4, findString     # secundo bloco temrina em virgula, não tem espaço vazio
	beq $a3, $zero, findString   # verifica se ambas as palavras terminaram
	j diferents

findString:
	addi $sp, $sp, -4
	lw $ra, 0($sp)     	     # recupera referencia
	 
	#la $a0, bufferLinha
	#li $a1, 68
	#jal showBuffer
	
	addi $sp, $sp, 4
	lw $ra, 0($sp) 
	
	li $a1, 0	     	# $a1 = 0, caso encontre
	j closeFile

diferents:
	j searchStringOnFile
#FUNCOES PARA DATA---------------------------------------------------------------------------------------------------------------------------------------------------

solicitarhora: #ele entrega a hora e solicita a data 
        # Obtém o tempo atual em milissegundos (syscall 30)
        li $v0, 30      # syscall 30: obtém o tempo do sistema (em milissegundos desde a época)
        syscall
        move $t0, $a0   # Armazena a parte baixa do tempo em $t0 (milissegundos)
        move $t1, $a1   # Armazena a parte alta do tempo em $t1 (milissegundos)

        # Converte para segundos totais (milissegundos / 1000)
        li $t2, 1000    # Carrega o valor 1000 em $t2 (usado como divisor para converter milissegundos para segundos)
        divu $t0, $t2   # Divide a parte baixa (milissegundos) por 1000
        mflo $t3        # Armazena o resultado da divisão (segundos totais) em $t3
        mfhi $t4        # Armazena o resto da divisão (milissegundos restantes) em $t4
        
        divu $t1, $t2   # Divide a parte alta do tempo (milissegundos) por 1000 para converter para segundos
        mflo $t5        # Armazena os segundos da parte alta em $t5

        add $t3, $t3, $t5 # Soma os segundos da parte baixa e alta, totalizando os segundos completos em $t3

        # Calcula as horas no formato UTC
        li $t6, 3600    # Carrega o valor 3600 (segundos em 1 hora) em $t6
        divu $t3, $t6   # Divide os segundos totais por 3600 para calcular as horas
        mflo $t7        # Armazena o número de horas em $t7
        rem $t7, $t7, 24  # Calcula o resto da divisão para garantir que as horas estejam no intervalo 0-23 (hora do dia)

        # Ajuste de fuso horário: subtrai 1 hora e 13 minutos (4380 segundos)
        li $t8, 4380    # Carrega o valor 4380 (1 hora e 13 minutos em segundos) em $t8
        sub $t3, $t3, $t8  # Subtrai 4380 segundos (ajuste de fuso horário UTC-1h13min)

        # Subtrai mais 3 horas (10.800 segundos) do tempo
        li $t9, 10800   # Carrega o valor 10800 (3 horas em segundos) em $t9
        sub $t3, $t3, $t9  # Subtrai 10.800 segundos do total de segundos (ajuste de fuso horário UTC-3h)

        # Calcula novas horas após os ajustes
        divu $t3, $t6   # Divide os segundos restantes por 3600 para calcular as horas ajustadas
        mflo $t7        # Armazena o número de horas ajustadas em $t7
        rem $t7, $t7, 24  # Calcula o resto da divisão para garantir que as horas ajustadas estejam no intervalo 0-23

        # Imprimir a hora ajustada
        li $v0, 4       # Código da syscall para imprimir uma string
        la $a0, msg     # Endereço da mensagem "Hora ajustada: "
        syscall

        # Imprime as horas
        move $a0, $t7   # Move o valor das horas ajustadas para $a0
        li $v0, 1       # Código da syscall para imprimir um número inteiro
        syscall

        # Imprime ":" (separador)
        li $v0, 4       # Código da syscall para imprimir uma string
        la $a0, sep     # Endereço do separador ":"
        syscall

        # Calcula os minutos
        li $t6, 60      # Carrega o valor 60 (segundos em 1 minuto) em $t6
        divu $t3, $t6   # Divide os segundos restantes por 60 para calcular os minutos
        mfhi $t8        # Armazena os segundos restantes após calcular as horas em $t8
        mflo $t9        # Armazena os minutos totais em $t9
        rem $t9, $t9, 60  # Calcula os minutos atuais, no intervalo 0-59

        # Imprime os minutos
        move $a0, $t9   # Move o valor dos minutos para $a0
        li $v0, 1       # Código da syscall para imprimir um número inteiro
        syscall

        # Imprime ":" (separador)
        li $v0, 4       # Código da syscall para imprimir uma string
        la $a0, sep     # Endereço do separador ":"
        syscall

        # Imprime os segundos restantes
        move $a0, $t8   # Move o valor dos segundos restantes para $a0
        li $v0, 1       # Código da syscall para imprimir um número inteiro
        syscall

        # Imprime uma nova linha
        li $v0, 4       # Código da syscall para imprimir uma string
        la $a0, newl    # Endereço da string de nova linha
        syscall

        # Solicitar a data ao usuário
        li $v0, 4         # Código da syscall para imprimir uma string
        la $a0, prompt    # Endereço da string do prompt
        syscall

        # Ler a entrada do usuário (data)
        li $v0, 8         # Código da syscall para ler uma string
        la $a0, input     # Endereço onde a string será armazenada
        li $a1, 11        # Limite de caracteres (10 para a data e 1 para o terminador nulo)
        syscall

        # Aqui você pode processar ou validar a data conforme necessário

        jr $ra  # Retorna da função

bufferInputToUser:
# $a0 -> indice bufferUser
# $a1 -> indice bufferInput
	la $t1, bufferInput
	la $t0, bufferUser
	add $t1, $t1, $a1	
	add $t0, $t0, $a0
	
	lb $t3, 0($t1)		# recebe o caracter
	li $t4, ' '
	beq $t3, $t4, return	# se tiver acabado retorna
	beqz $t3, return
	sb $t3, 0($t0)		# salva o caracter
	
	addi $a0, $a0, 1 
	addi $a1, $a1, 1
	
	j bufferInputToUser
	
#FUNCOES DE CRIACAO DE ELEMENTOS -----------------------------------------------------------------------------------------------------------------------
creatUser:
	addi $sp, $sp, -4   
	sw $ra, 0($sp)     	     # salvar referencia
	
	li $a0, 0 		     # indiceUser
	li $a1, 4		     # indiceInput
	
	#Nome
	jal bufferInputToUser
	
	addi $a1, $a1, 1
	move $t2, $a1
	
	la $a0, bufferUser  	     # parametros da funcao -> buffer(commaInBuffer) 
	li $a1, 30		     # parametros da funcao  -> indice do buffer (commaInBuffer)
	jal commaInBuffer
	
	move $a1, $t2
	
	#Matricula
	li $a0, 31		     # indiceUser
	jal bufferInputToUser
	addi $a1, $a1, 1
	move $t2, $a1
	
	la $a0, bufferUser  	     # parametros da funaco -> buffer(	InBuffer)
	li $a1, 36		     # parametros da funcao  -> indice do buffer (commaInBuffer)
	jal commaInBuffer
	
	move $a1, $t2
	
	#Curso
	li $a0, 37		     # indiceUser
	jal bufferInputToUser
	
	#Quebra de linha
	la $a0, bufferUser
	addi $a0, $a0, 67
	li $t0, '\n'
	sb $t0, 0($a0)
	addi $s0, $s0,1
	
	#Mostrar Cadastro
	la $a0, bufferUser
	li $a1, 68
	jal showBuffer
	
	la $a0, usersFile	     # parametros da função -> arquivo(saveData) 
	la $a1, bufferUser	     # parametros da função -> buffer(saveData) 
	li $a2, 68	 	     # parametros da função -> tamanhoString(saveData) 
	jal saveData
	
	
	
	lw $ra, 0($sp)       	     # recupera referencia do chamdaor
	addi $sp, $sp, 4    
	
	j return

creatBook:
	addi $sp, $sp, -4   
	sw $ra, 0($sp)     	     # salvar referencia
	
	li $a0, 0 		     # indiceUser
	li $a1, 4		     # indiceInput
	
	#livro
	jal bufferInputToUser
	
	addi $a1, $a1, 1
	move $t2, $a1
	
	la $a0, bufferUser  	     # parametros da funcao -> buffer(commaInBuffer) 
	li $a1, 30		     # parametros da funcao  -> indice do buffer (commaInBuffer)
	jal commaInBuffer
	
	move $a1, $t2
	
	#ISBM
	li $a0, 31		     # indiceUser
	jal bufferInputToUser
	addi $a1, $a1, 1
	move $t2, $a1
	
	la $a0, bufferUser  	     # parametros da funaco -> buffer(commaInBuffer)
	li $a1, 36		     # parametros da funcao  -> indice do buffer (commaInBuffer)
	jal commaInBuffer
	
	move $a1, $t2		     # indice do Input
	
	#Autor
	li $a0, 37		     # indiceUser
	move $a3, $a1		     # indice atual do bufferInput, sera usado para calcular quantos caracteres foram lidos
	jal bufferInputToUser
	
	addi $a1, $a1, 1
	move $t2, $a1		     # indice do Input
	
	sub $a3, $a1, $a3	     # numero de caracteres do autor
	add $a1, $a3, 36	     # indice do ' - '
	
	jal breakIsbmAmount
	
	move $t3, $a1
	move $a1, $t2		     # indice do Input
	
	#Quantidade de livros
	move $a0, $t3		     # indiceUser
	jal bufferInputToUser
	
	#Quebra de linha
	la $a0, bufferUser
	addi $a0, $a0, 67
	li $t0, '\n'
	sb $t0, 0($a0)
	addi $s0, $s0,1
	
	#Mostrar Cadastro
	la $a0, bufferUser
	li $a1, 68
	jal showBuffer
	
	la $a0, booksFile	     # parametros da função -> arquivo(saveData) 
	la $a1, bufferUser	     # parametros da função -> buffer(saveData) 
	li $a2, 68	 	     # parametros da função -> tamanhoString(saveData) 
	jal saveData
	
	jal clearBufferUser
	
	lw $ra, 0($sp)       	     # recupera referencia do chamdaor
	addi $sp, $sp, 4    
	
	j return
	
creatBookLoan:
	addi $sp, $sp, -4   
	sw $ra, 0($sp)     	     # salvar referencia
	
	li $a0, 0 		     # indiceUser
	li $a1, 4		     # indiceInput
	
	#Matricula
	jal bufferInputToUser
	
	addi $a1, $a1, 1
	move $t2, $a1
	
	la $a0, bufferUser  	     # parametros da funcao -> buffer(commaInBuffer) 
	li $a1, 30		     # parametros da funcao  -> indice do buffer (commaInBuffer)
	jal commaInBuffer
	
	move $a1, $t2
	
	#ISBM
	li $a0, 31		     # indiceUser
	jal bufferInputToUser
	addi $a1, $a1, 1
	move $t2, $a1
	
	la $a0, bufferUser  	     # parametros da funaco -> buffer(commaInBuffer)
	li $a1, 36		     # parametros da funcao  -> indice do buffer (commaInBuffer)
	jal commaInBuffer
	
	move $a1, $t2		     # indice do Input
	
	#Data atual
	li $a0, 37		     # indiceUser
	move $a3, $a1		     # indice atual do bufferInput, sera usado para calcular quantos caracteres foram lidos
	jal bufferInputToUser
	
	addi $a1, $a1, 1
	move $t2, $a1		     # indice do Input
	
	sub $a3, $a1, $a3	     # numero de caracteres do autor
	add $a1, $a3, 36	     # indice do ' - '
	
	jal breakIsbmAmount
	
	move $t3, $a1
	move $a1, $t2		     # indice do Input
	
	#Quantidade de livros
	move $a0, $t3		     # indiceUser
	jal calculateReturnDate
	
	#Quebra de linha
	la $a0, bufferUser
	addi $a0, $a0, 67
	li $t0, '\n'
	sb $t0, 0($a0)
	addi $s0, $s0,1
	
	#Mostrar Cadastro
	la $a0, bufferUser
	li $a1, 68
	jal showBuffer
	
	la $a0, booksFile	     # parametros da função -> arquivo(saveData) 
	la $a1, bufferUser	     # parametros da função -> buffer(saveData) 
	li $a2, 68	 	     # parametros da função -> tamanhoString(saveData) 
	jal saveData
	
	jal clearBufferUser
	
	lw $ra, 0($sp)       	     # recupera referencia do chamdaor
	addi $sp, $sp, 4    
	
	j return
	
# FUNCOES MUITO USADAS --------------------------------------------------------------------------------------------------------------------

# FUNCOES COLOCAR CARACTER ------------------------------------------
breakIsbmAmount:
# $a1 -> indice do buffer
# Retorna o indice em $a1 
	li $t1, ' '        	     # caracter 
	
	la $t0, bufferUser
	
	add $t0, $t0, $a1	     # endereço do proximo elemento
	sb $t1, 0($t0)      	   
	  
	addi $t0, $t0, 1
	li $t1, '-'  		     # caracter 
	sb $t1, 0($t0)
	
	addi $t0, $t0, 1
	li $t1, ' '  		      # caracter 
	sb $t1, 0($t0)
	
	addi $a1, $a1, 3             # +3 indice bufferUser
	j return

commaInBuffer:
# apos o uso tem que atualizar o valor do indice do buffer
# Parametro
# $a0 -> buffer
# $a1 -> indice do buffer	
	li $t1, 0x2C        	     # caracter da virgula
	add $t0, $a0, $a1
	sb $t1, 0($t0)      	     # virgula no buffer
	addi $a1, $a1, 1             # +1 indice bufferUser
	j return
	
barInBuffer:
# apos o uso tem que atualizar o valor do indice do buffer
# Parametro
# $a0 -> buffer
# $a1 -> indice do buffer

	li $t1, '/'        	     
	add $t0, $a0, $a1
	sb $t1, 0($t0)      	     # barra no buffer
	addi $a1, $a1, 1             # +1 indice bufferUser
	j return

# FUNCOES DE BUFFER ------------------------------------------

showBuffer:
# Parâmetros
# $a0 -> buffer
# $a1 -> indice (numero de elementos no buffer)
	addi $sp, $sp, -4   
	sw $ra, 0($sp)     	     # salvar referencia
	
	move $t7, $a0
	
	jal loopshowBuffer
	
	move $a0, $t7
	lw $ra, 0($sp)       	     # recupera referencia do chamdaor
	addi $sp, $sp, 4    
	
	j return
	
loopshowBuffer:
	subi $a1, $a1, 1    # Decrementa o contador
	move $t1, $a0       # buffer
	lb $a0, 0($t1)      # caractere do buffer
	li $v0, 11          # imprimir caractere
	syscall
	move $a0, $t1
	addi $a0, $a0, 1    # Avança para o próximo caractere
	beqz $a1, return    # Se o índice for 0, chegou no ultimo
	j loopshowBuffer       # Continua a exibição

# FUNCOES DE MMIO -----------------------------------------------
inputUser:
	li $t0, 0xFFFF0000         # endereço do keyboard status
	lw $t1, 0($t0)             # status do teclado, bit menos significativo = 0 -> sem caracter indisponivel
	andi $t1, $t1, 1           # operação AND para verificar o bit menos significativo
	beq $t1, $zero, inputUser     

	# le caractere do teclado
	li $t0, 0xFFFF0004         # endereço do keyboard data
	lw $a0, 0($t0)             # carrega o caracter
	li $t3, 0x0A 		   # Enter
	beq $a0, $t3, return
	la $t2, bufferInput 
	add $t2, $t2, $s0
	sb $a0, 0($t2)   	    # salva no buffer
	addi $s0, $s0, 1	    # +1 indice bufferUser
	j loopDisplay
	
loopDisplay:
#parametro $a0 -> byte pra exibir
	li $t0, 0xFFFF0008       # endereço do display status
	lw $t1, 0($t0)           # status do Display, bit menos significativo = 0 -> display indisponivel
	andi $t1, $t1, 1         
	beq $t1, $zero, loopDisplay

	li $t0, 0xFFFF000C       # endereço do display data
	sw $a0, 0($t0)           # escrita	
	j inputUser      

cleardDisplay:
	li $a0, 25       	 # linhas em branco (contador)
	j clearLoop
	
clearLoop:
	li $t1, 0xFFFF0008         # endereço do display status
	lw $t2, 0($t1)             # status do display
	andi $t2, $t2, 1
	beq $t2, $zero, clearLoop  # se ocupado, espera
	li $t1, 0xFFFF000C         # endereço do display data
	
	li $t0, 0x0A               # pula linha
	sw $t0, 0($t1)             # escreve
	subi $a0, $a0, 1           # -1 contador
	bgtz $a0, clearLoop        # Repete até o contador chegar a 0

 	jr $ra    
 	
showMsg:
# Parametro 
# $a0 -> mensagem
	lb $t0, 0($a0)		  #caractere
	beqz $t0, return	  #verifica se terminou
	li $t1, 0xFFFF0008        # endereço do display status
	j loopDisplaymsg    	  #loop escrita
	
loopDisplaymsg:
	lw $t2, 0($t1)           # status do display
	andi $t2, $t2, 1         
	beq $t2, $zero, loopDisplaymsg  # se ocupado, espera

	li $t1, 0xFFFF000C       # endereço do display data
	sw $t0, 0($t1)           # escreve

	addi $a0, $a0, 1  	 # proximo caractere
	j showMsg    

saveData:
# Parâmetros
# $a0 -> Nome do arquivo
# $a1 -> Endereco da string a ser salva (buffer)
# $a2 -> Tamanho da string a ser salva

	move $t0, $a1
	move $t1, $a2
	
	li $v0, 13           # abrir arquivo
	move $a0, $a0	     # nome do arquivo
	li $a1, 9            # append
	li $a2, 0            # permissoes 
	syscall
	move $t3, $v0        # descritor do arquivo

	# Escrita no arquivo
	li $v0, 15           # escrita
	move $a0, $t3        # descritor do arquivo
	move $a1, $t0        # endereço String
	move $a2, $t1        # tamanho String
	syscall
	
	j closeFile

openFile:
# Parametros
# $a0 -> nome do arquivo
	li $v0, 13 		#solicita a  abertura do arquivo USer
				#nome do arquivo 
	li $a1, 0 		#leitura do arquvo
	syscall 		#Descritor do arquivo vai para $v0
	
	move $s1, $v0 		#copia do descritor
	
	j return
	
readFile:
	move $a0, $s1		# descritor
	li $v0, 14 		# ler o conteudo referenciado por $a1
	la $a1, bufferLinha 	# buffer que armazena o conteudo
	li $a2, 68 		# tamanho do buffer
	syscall
 
	blez $v0, endOfFile	# Se nao tiver mais nada para ler
	
	j return
	
endOfFile:
	li $a1, -1		# Caso chegue ao final do arquivo, não encontrou a string 
	j closeFile
	
closeFile:
# Parametros
# $a0 -> nome do arquivo	

	li $v0, 16
	move $a0, $a0
	syscall

	j return
	
clearBufferUser:
	addi $sp, $sp, -4   
	sw $ra, 0($sp)     	     # salvar referencia
	
	la $a0, bufferUser
	add $a1, $a0, 68
	jal loopClearBuffer
	li $s0, 0
	
	lw $ra, 0($sp) 		     # recupera referencia
	addi $sp, $sp, 4   

	j return

loopClearBuffer:
# $a0 -> endereço buffer
# $a1 -> endereço buffer + contador
	li $t0, 0x00		     # Nulo	
	sb $t0, 0($a0)
	addi $a0, $a0, 1
	beq $a0, $a1, return
	j loopClearBuffer

endRun:
	li $v0, 10   
	syscall      
return:
	jr $ra
	
calculateReturnDate:
# parametro
# $a0 -> endere�o da onde deve ser impresso (presica voltar 13 posi��es par apegar a data atual)
	addi $a0, $a0, -13
	#Dia
    	lb   $t1, 0($a0)    # decimal
    	lb   $t2, 1($a0)    # unidade

    	# Converter caracteres para n�meros inteiros
    	subi $t1, $t1, 48   
    	subi $t2, $t2, 48   

    	
    	li   $t3, 10        # Multiplicador
    	mul  $t1, $t1, $t3  # Multiplica o decimal por 10
	add  $t1, $t1, $t2  # Soma o segundo n�mero

    	#Mes
	lb   $t2, 3($a0)    # decimal
    	lb   $t4, 4($a0)    # unidade

    	# Converter caracteres para n�meros inteiros
    	subi $t2, $t2, 48   
    	subi $t4, $t4, 48   

    	li   $t3, 10        # Multiplicador
    	mul  $t2, $t2, $t3  # Multiplica o decimal por 10
	add  $t2, $t2, $t4  # Soma o segundo n�mero
	
	#Ano
	lb   $t4, 6($a0)    # 1000
    	lb   $t5, 7($a0)    # 100
    	lb   $t6, 8($a0)    # 10
    	lb   $t7, 9($a0)    # 1
	    	
	subi $t4, $t4, 48   
    	subi $t5, $t5, 48   
    	subi $t6, $t6, 48 
    	subi $t7, $t7, 48 
    	
    	li   $t3, 1000        
    	mul  $t4, $t4, $t3    # Multiplica por 1000
    	li   $t3, 100   
	add  $t5, $t5, $t3    # Soma o segundo n�mero
    	li   $t3, 10   
    	#Soma
	add  $t6, $t6, $t3    
	add  $t4, $t4, $t5  
	add  $t4, $t4, $t6  
	add  $t4, $t4, $t7  

    	# Adicionar 10 dias ao dia
    	addi $t1, $t1, 10          # Incrementa 10 no dia

    	# Verificar se o dia ultrapassou 31
    	bgt $t1, 31, adjustMonth   # Se o dia ultrapassou 31, ajusta o m�s
    	
    	j putDateLoanOnBufferUser

adjustMonth:
    	sub $t1, $t1, 31           # Subtrai 31 dias para ajustar o m�s
    	addi $t2, $t2, 1           # Avan�a para o pr�ximo m�s

    	# Se o m�s for maior que 12, ajusta o ano
    	bgt $t2, 12, adjustYear    # Se o m�s for maior que 12 (dezembro), ajusta o ano
    	j putDateLoanOnBufferUser

adjustYear:
    	addi $t3, $t3, 1           # Incrementa o ano
    	li $t2, 1                  # Reseta o m�s para janeiro
    	j putDateLoanOnBufferUser
    	
putDateLoanOnBufferUser:
# $t1 -> dia
# $t2 -> mes
# $t4 -> Ano
	
	addi  $t3, $a0, 13  # Ponteiro para armazenar a string
   	# Converter dia para caracteres 
    	
    	div  $t0, $zero, 10  # $LO = dia / 10, $HI = dia % 10
    	mflo $t4             # Primeiro d�gito (dezena)
    	mfhi $t5             # Segundo d�gito (unidade)

    	addi $t4, $t4, 48    # Converter para ASCII
    	addi $t5, $t5, 48

    	sb   $t4, 0($t3)     # Armazena o primeiro d�gito do dia
    	sb   $t5, 1($t3)     # Armazena o segundo d�gito do dia

    	# Inserir '/'
    	li   $t6, 47         # ASCII de '/'
    	sb   $t6, 2($t3)

    	# ---------------------------
    	# Converter m�s para caracteres ASCII
    	# ---------------------------
    	div  $t1, $zero, 10
    	mflo $t4
    	mfhi $t5

    	addi $t4, $t4, 48
    	addi $t5, $t5, 48

    	sb   $t4, 3($t3)     # Armazena primeiro d�gito do m�s
    	sb   $t5, 4($t3)     # Armazena segundo d�gito do m�s

    	# Inserir '/'
    	sb   $t6, 5($t3)

    	# ---------------------------
    	# Converter ano para caracteres ASCII
    	# ---------------------------
    	div  $t2, $zero, 1000
    	mflo $t7             # Primeiro d�gito do ano
    	mfhi $t2             # Resto (�ltimos tr�s d�gitos)

    	addi $t7, $t7, 48
    	sb   $t7, 6($t3)

   	 div  $t2, $zero, 100
    	mflo $t7             # Segundo d�gito do ano
    	mfhi $t2             # �ltimos dois d�gitos

    	addi $t7, $t7, 48
    	sb   $t7, 7($t3)

    	div  $t2, $zero, 10
    	mflo $t7             # Terceiro d�gito do ano
    	mfhi $t2             # �ltimo d�gito do ano

    	addi $t7, $t7, 48
    	sb   $t7, 8($t3)

    	sb   $t2, 9($t3)

	j return
	
